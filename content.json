{"meta":{"title":"Charm's Blog","subtitle":null,"description":"编程学习实践blog","author":"Charm Sun","url":"https://charmsun.github.io"},"pages":[],"posts":[{"title":"前端自动化单元测试","slug":"front-end-unit-testing","date":"2018-04-03T08:13:05.000Z","updated":"2018-04-25T10:11:14.402Z","comments":true,"path":"2018/04/03/front-end-unit-testing/","link":"","permalink":"https://charmsun.github.io/2018/04/03/front-end-unit-testing/","excerpt":"","text":"随着Web业务的日益复杂化和多元化，前端开发也有了前端工程化的概念，前端工程化成为目前前端架构中重要的一环，本质上也是软件工程的一种，因此我们需要从软件工程的角度来研究前端工程，而自动化测试则是软件工程中重要的一环。本文就研究一下前端领域中的自动化测试，以及如何实践。 什么是单元测试 单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般来说，要根据实际情况去判定其具体含义，如C语言中单元指一个函数，Java里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。——百度百科 为何要测试以前没有编写和维护测试用例的习惯，在项目的紧张开发周期中也没时间去做这个工作，相信有不少开发人员都不会重视单元测试这项工作。在真正写了一段时间基础组件后，才发现自动化测试有很多好处: 提升代码质量。虽不能说百分百无bug，但至少说明测试用例覆盖到的场景是没有问题的。 能快速反馈，能确定UI组件工作情况是否符合自己预期。 开发者会更加信任自己的代码，也不会惧怕将代码交给别人维护。后人接手一段有测试用例的代码，修改起来也会更加从容。测试用例里非常清楚的阐释了开发者和使用者对于这段代码的期望和要求，也非常有利于代码的传承。 当然由于维护测试用例也是一大笔开销，还是要基于投入产出比来做单元测试。对于像基础组件、基础模型之类的不常变更且复用较多的部分，可以考虑写测试用例来保证质量，但对于迭代较快的业务逻辑及生存时间不长的部分就没必要浪费时间了。 因此github上看到的star较多的牛逼开源前端项目基本上都是有测试代码的，看来业界大牛们都是比较重视单元测试这块的。 相关概念TDDTDD是Test Driven Development 的缩写，也就是测试驱动开发。 通常传统软件工程将测试描述为软件生命周期的一个环节，并且是在编码之后。但敏捷开发大师Kent Beck在2003年出版了 Test Driven Development By Example 一书，从而确立了测试驱动开发这个领域。 TDD需要遵循如下规则： 写一个单元测试去描述程序的一个方面。 运行它应该会失败，因为程序还缺少这个特性。 为这个程序添加一些尽可能简单的代码保证测试通过。 重构这部分代码，直到代码没有重复、代码责任清晰并且结构简单。 持续重复这样做，积累代码。 TDD具有很强的目的性，在直接结果的指导下开发生产代码，然后不断围绕这个目标去改进代码，其优势是高效和去冗余的。所以其特点应该是由需求得出测试，由测试代码得出生产代码。打个比方就像是自行车的两个轮子，虽然都是在向同一个方向转动，但是后轮是施力的，带动车子向前，而前轮是受力的，被向前的车子带动而转。 BDD所谓的BDD行为驱动开发，即Behaviour Driven Development，是一种新的敏捷开发方法。它更趋向于需求，需要共同利益者的参与，强调用户故事（User Story）和行为。2009年，在伦敦发表的“敏捷规格，BDD和极限测试交流”中，Dan North对BDD给出了如下定义： BDD是第二代的、由外及内的、基于拉(pull)的、多方利益相关者的(stakeholder)、多种可扩展的、高自动化的敏捷方法。它描述了一个交互循环，可以具有带有良好定义的输出（即工作中交付的结果）：已测试过的软件。 它对TDD的理念进行了扩展，在TDD中侧重点偏向开发，通过测试用例来规范约束开发者编写出质量更高、bug更少的代码。而BDD更加侧重设计，其要求在设计测试用例的时候对系统进行定义，倡导使用通用的语言将系统的行为描述出来，将系统设计和测试用例结合起来，从而以此为驱动进行开发工作。 大致过程： 从业务的角度定义具体的，以及可衡量的目标 找到一种可以达到设定目标的、对业务最重要的那些功能的方法 然后像故事一样描述出一个个具体可执行的行为。其描述方法基于一些通用词汇，这些词汇具有准确无误的表达能力和一致的含义。例如，expect, should, assert 寻找合适语言及方法，对行为进行实现 测试人员检验产品运行结果是否符合预期行为。最大程度的交付出符合用户期望的产品，避免表达不一致带来的问题 覆盖率如何衡量测试脚本的质量呢？其中一个参考指标就是代码覆盖率（coverage）。 什么是代码覆盖率？简而言之就是测试中运行到的代码占所有代码的比率。其中又可以分为行数覆盖率，分支覆盖率等。具体的含义不再细说，有兴趣的可以自行查阅资料。 虽然并不是说代码覆盖率越高，测试的脚本写得越好，但是代码覆盖率对撰写测试脚本还是有一定的指导意义的。 前端单测工具栈测试框架主要提供了清晰简明的语法来描述测试用例，以及对测试用例分组，测试框架会抓取到代码抛出的AssertionError，并增加一大堆附加信息，比如那个用例挂了，为什么挂等等。目前比较流行的测试框架有： Jasmine： 自带断言（assert）,mock功能 Mocha： 框架不带断言和mock功能，需要结合其他工具，由tj大神开发 Jest： 由Facebook出品的测试框架，在Jasmine测试框架上演变开发而来 断言库断言库提供了很多语义化的方法来对值做各种各样的判断。 chai: 目前比较流行的断言库，支持 TDD（assert），BDD（expect、should）两种风格 should.js：也是tj大神所写 mock库 sinon.js：使用Sinon，我们可以把任何JavaScript函数替换成一个测试替身。通过配置，测试替身可以完成各种各样的任务来让测试复杂代码变得简单。支持 spies, stub, fake XMLHttpRequest, Fake server, Fake time，很强大 测试集成管理工具 karma：Google Angular 团队写的，功能很强大，有很多插件。可以连接真实的浏览器跑测试。能够用一些测试覆盖率统计的工具统计一下覆盖率；或是能够加入持续集成，提交代码后自动跑测试用例。 测试脚本的写法通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。 123456789// add.test.jsvar add = require(&apos;./add.js&apos;);var expect = require(&apos;chai&apos;).expect;describe(&apos;加法函数的测试&apos;, function() &#123; it(&apos;1 加 1 应该等于 2&apos;, function() &#123; expect(add(1, 1)).to.be.equal(2); &#125;);&#125;); 上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个describe块，每个describe块应该包括一个或多个it块。 describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。 describe干的事情就是给测试用例分组。为了尽可能多的覆盖各种情况，测试用例往往会有很多。这时候通过分组就可以比较方便的管理（这里提一句，describe是可以嵌套的，也就是说外层分组了之后，内部还可以分子组）。另外还有一个非常重要的特性，就是每个分组都可以进行预处理（before、beforeEach）和后处理（after, afterEach）。 it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。 大型项目有很多测试用例。有时，我们希望只运行其中的几个，这时可以用only方法。describe块和it块都允许调用only方法，表示只运行某个测试套件或测试用例。此外，还有skip方法，表示跳过指定的测试套件或测试用例。1234567describe.only(&apos;something&apos;, function() &#123; // 只会跑包在里面的测试&#125;)it.only(&apos;do do&apos;, () =&gt; &#123; // 只会跑这一个测试&#125;) react 单测示例一react 单元测试框架 demo1 该框架采用 karma + mocha + chai + sinon 的组合， 是一种采用工具较多，同时自由度较高的解决方案。虽然工具库使用的较多，但有助于理解各个工具库的作用和使用，也有助于加深对前端单元测试的理解。 其中React的测试库使用 enzyme，React测试必须使用官方的测试工具库，但是它用起来不够方便，所以有人做了封装，推出了一些第三方库，其中Airbnb公司的Enzyme最容易上手。 关于该库的 api 使用可参考： 官方文档 阮老师React测试入门 react 单测示例二react 单元测试框架 demo2 该框架只采用了Jest，是比较简洁的方案，同样也使用了 enzyme。 Jest 是Facebook开发的一个测试框架，它集成了测试执行器、断言库、spy、mock、snapshot和测试覆盖率报告等功能。React项目本身也是使用Jest进行单测的，因此它们俩的契合度相当高。之前仅在其内部使用，后开源，并且是在Jasmine测试框架上演变开发而来，使用了熟知的expect(value).toBe(other)这种断言格式。 PS: 目前 enzyme 使用时需要加入设置如下：1234import Enzyme from &apos;enzyme&apos;;import Adapter from &apos;enzyme-adapter-react-16&apos;;Enzyme.configure(&#123; adapter: new Adapter() &#125;); 上面两个框架方案中都有加入该配置的方法，详见示例。 参考 聊一聊前端自动化测试 前端自动化单元测试初探 Javascript的Unit Test 单元测试all in one Sinon指南: 使用Mocks, Spies 和 Stubs编写JavaScript测试 测试框架 Mocha 实例教程","categories":[{"name":"前端","slug":"前端","permalink":"https://charmsun.github.io/categories/前端/"}],"tags":[{"name":"前端单元测试","slug":"前端单元测试","permalink":"https://charmsun.github.io/tags/前端单元测试/"}]},{"title":"前端持续集成","slug":"front-end-ci","date":"2018-04-03T07:18:51.000Z","updated":"2018-04-25T10:11:14.386Z","comments":true,"path":"2018/04/03/front-end-ci/","link":"","permalink":"https://charmsun.github.io/2018/04/03/front-end-ci/","excerpt":"","text":"编写代码只是软件开发的一小部分，更多的时间往往花在构建（build）和测试（test）。之前介绍了前端的单元测试，这篇再介绍和实践一下前端的持续集成（Continuous integration），简写为CI。 什么是持续集成 持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。 持续集成的益处： 减少风险 减少重复过程 任何时间、任何地点生成可部署的软件 增强项目的可见性 建立团队对开发产品的信心 集成工具GitHub 上比较主流的持续集成工具有 Travis CI 和 Circle CI；分别占市场占有率前两位，两者的功能和使用都比较相似，其中Travis CI用的最多，就选择Travis CI进行介绍。 Travis CI 只支持 Github，不支持其他代码托管服务。这意味着，你必须满足以下条件，才能使用 Travis CI。 拥有 GitHub 帐号 该帐号下面有一个项目 该项目里面有可运行的代码 该项目还包含构建或测试脚本 Travis有两个网址，org的那个是非盈利的，为GitHub上public的repository提供免费服务；com的那个是盈利的，可以对private的提供付费服务。com前100次build是免费的，此后按月收费。 使用很简单，用GitHub 账号登录后,Travis 会列出 Github 上面你的所有仓库，以及你所属于的组织。此时，选择你需要 Travis 帮你构建的仓库，打开仓库旁边的开关。一旦激活了一个仓库，Travis 会监听这个仓库的所有变化。 流程很简明，但绝大多数复杂度都集中在这个.travis.yml文件。这是一个YAML文件，主要用来做CI的配置。Travis会按照这个文件配置的方式来运行。以下是项目中使用travis的简单例子：123456789101112131415161718language: node_jsnode_js: - &quot;8&quot;install: - npm install -g codecov - npm installbefore_script: - &quot;export DISPLAY=:99.0&quot; - &quot;sh -e /etc/init.d/xvfb start&quot; - sleep 3 # give xvfb some time to startscript: - cross-env TRAVIS=true karma start --single-run - codecov Travis 的运行流程很简单，任何项目都会经过两个阶段。 12- install 阶段：安装依赖- script 阶段：运行脚本 Node 项目的install和script阶段都有默认脚本，可以省略。 12- install 默认值：npm install- script 默认值：npm test 完整的生命周期，从开始到结束是下面的流程: 1234567891. before_install2. install3. before_script4. script5. aftersuccess or afterfailure6. [OPTIONAL] before_deploy7. [OPTIONAL] deploy8. [OPTIONAL] after_deploy9. after_script 更多用法可查阅官方文档，官方文档比较详细。 在上面的例子中，每次代码 push 以后，Travis 会自动开始构建，并运行单测，最后得到构建状态如下 点击状态图标，可以在弹出界面中得到该项目的状态图标链接。放到repository的README.md中，就可以在GitHub页面得到编译状态的展示了。 另外，如果多次提交同时push，默认只在最新提交执行一次build；在git commit中如果包含[skip ci]或[ci skip]，该提交就不会触发一次build。 集成测试覆盖率工具代码覆盖率报告可以为编写测试程序提供参考，通过一些工具，还可以及时的把你的代码的测试情况及时的反馈给用户，让用户感知你的测试是否完备。 GitHub 上比较主流的代码覆盖率集成工具有 codecov 和 coveralls；两者也差不多，在之前travis的例子中选择使用了codecov。 同样使用GitHub 账号登录，第一次使用时，默认是没有 repository 的，需要通过点击 + Add my first repository 来添加需要 codecov 管理的 repository。无论 codecov 还是 coveralls，它自身都不会去运行测试用例来获得项目代码的覆盖率，而是通过收集覆盖率报告及其他关键信息来静态分析。codecov 可以接收 lcov, gcov 以及正确的 json 数据格式作为输入信息。 该例子就是在travis CI 平台中跑完测试用例后，将测试报告中的 lcov 和 json 文件提交至codecov 平台进行覆盖率分析，同样分析的覆盖率结果的徽章图标也能从平台中获取，可以加入到GitHub repository 的README.md中。 123456789101112131415161718language: node_jsnode_js: - &quot;8&quot;install: - npm install -g codecov - npm installbefore_script: - &quot;export DISPLAY=:99.0&quot; - &quot;sh -e /etc/init.d/xvfb start&quot; - sleep 3 # give xvfb some time to startscript: - cross-env TRAVIS=true karma start --single-run - codecov 跨浏览器集成测试浏览器端使用的库，在各个浏览器端的兼容性也是非常重要的。跨浏览器测试同样有 2 个选择，SAUCELABS 和 BrowserStack，可以进行浏览器兼容性测试。这里没有详细实践过，怎么操作可以去参考文章看。 至此，CI 除了能跑跑测试、显示覆盖率之外，还能自动部署发布，怎样部署也在 yaml文件中进行脚本编写，这里就不举例子了。以上说的都是源代码放在 Github 上的开源代码，但相信大家接触得更多的应该是公司的私有代码，私有代码的项目也有 CI 解决方案，就是Jenkins，其前身是 Hudson （相信大家都见过，我们用的所谓的编译平台就是这个东东，但估计主动去用的不多）。 Jenkins这里 搭建了一个 Jenkins， http://10.134.72.178:8080/jenkins/，搭建过程不细说，说下能解决什么问题。比如有这样的场景： 前后端分离后希望将前端主干代码部署至服务器； 新项目尚未接入考拉平台，希望可以部署至服务器供联调； 能每次代码提交后都能自动构建自动部署，无须任何操作； 项目紧张时，领导希望能看到每天程序员提交代码后，项目的进展情况等。 这些场景下， Jenkins 都能帮助解决，凡是需要自动构建自动部署的，它都能帮上忙。这里举例大致说下怎么使用，就以将某个业务系统前端代码自动构建部署至nginx服务器为例。 第一步：新建项目，左边菜单第一项。 第二步：进行相关配置，填写源码配置，可选择仓库源，git和svn都支持。 第三步：进行构建触发配置，可设置触发构建的情形，例如代码提交时构建，按日程表构建等。 第四步：填写构建部署脚本。 第五步：保存并进行构建，查看构建情况。 详细配置可以上Jenkins中查看，构建过程包括自动更新svn代码，安装或更新npm包，进行webpack打包，将打包后的代码部署至静态资源服务器。至此完成前端代码的构建和部署，每次提交代码，构建过程全自动运行，当状态指示灯变蓝时就表示构建成功，我们可以访问服务器前端资源了。 这只是一个比较简单的例子，还有不少其他功能，Jenkin有很多插件，总之很强大。当然不同的项目可能会有不同的构建过程，可以自己按需设定构建过程。 结语结尾来个段子： 以前我坚持认为代码应该是 clean 的，架构应该是简洁的，流程应该是自动化的，文档应该是齐全的，技术是应该分享的。 效率较高不加班，结果 kpi 被差评，领导认为我无所事事。 最近半年我换了风格，架构重度设计，类名变量模糊不清，没有注释，现在大家都离不开我了，kpi 也上去了。 段子笑一笑而已，最后还是希望能运用到前面的持续集成工具来实现流程自动化，重复性的工作尽量交给机器自己动。 参考 前端开源项目持续集成三剑客 持续集成服务 Travis CI 教程 前端持续集成解决方案 从GitHub到Travis","categories":[{"name":"前端","slug":"前端","permalink":"https://charmsun.github.io/categories/前端/"}],"tags":[{"name":"前端工程化","slug":"前端工程化","permalink":"https://charmsun.github.io/tags/前端工程化/"}]}]}